import { FirstWidget } from './widgets/FirstWidget.js';
import { SecondWidget } from './widgets/SecondWidget.js';
import { VideoWidget } from './widgets/VideoWidget.js';
import { VideoWidget2 } from './widgets/VideoWidget2.js';
import { VideoWidget3 } from './widgets/VideoWidget3.js';
import { VideoWidget4 } from './widgets/VideoWidget4.js';
import { VideoWidget5 } from './widgets/VideoWidget5.js';
import { VideoWidget6 } from './widgets/VideoWidget6.js';
import { VideoWidget7 } from './widgets/VideoWidget7.js';
import { VideoWidget8 } from './widgets/VideoWidget8.js';
import { VideoWidget9 } from './widgets/VideoWidget9.js';
import { VideoWidget10 } from './widgets/VideoWidget10.js';

class WidgetManager {
    constructor() {
        this.widgetContainer = document.getElementById('widgetContainer');
        this.currentWidget = this.getInitialWidget();
        this.widgets = [];
        this.backgroundMusic = document.getElementById('bgMusic');
        this.politicalMusic = document.getElementById('politicalMusic');
        this.backgroundMusic.loop = true; // Enable continuous looping
        this.politicalMusic.loop = true; // Enable continuous looping
        this.currentAudioTrack = 'lavender'; // Track which audio is currently active
        this.setupAudioContext();
        this.setupCrossPageAudio();
        this.init();
        this.initializeResetMonitoring();
    }

    // Method to switch between audio tracks
    switchAudioTrack(trackName, volume = 0.08) {
        console.log(`ðŸŽµ Switching audio track to: ${trackName} at ${Math.round(volume * 100)}% volume`);
        
        if (trackName === 'political' && this.currentAudioTrack !== 'political') {
            // Switch from lavender to political
            this.backgroundMusic.pause();
            this.backgroundMusic.currentTime = 0;
            
            this.politicalMusic.volume = volume;
            this.politicalMusic.currentTime = 0;
            this.politicalMusic.play().catch(e => console.log('Political music playback failed:', e));
            
            this.currentAudioTrack = 'political';
            console.log('âœ… Switched to political party music');
            
        } else if (trackName === 'lavender' && this.currentAudioTrack !== 'lavender') {
            // Switch from political to lavender
            this.politicalMusic.pause();
            this.politicalMusic.currentTime = 0;
            
            this.backgroundMusic.volume = volume;
            this.backgroundMusic.currentTime = 0;
            this.backgroundMusic.play().catch(e => console.log('Lavender music playback failed:', e));
            
            this.currentAudioTrack = 'lavender';
            console.log('âœ… Switched to lavender soundtrack');
            
        } else if (trackName === this.currentAudioTrack) {
            // Just update volume for current track
            if (this.currentAudioTrack === 'political') {
                this.politicalMusic.volume = volume;
                if (this.politicalMusic.paused) {
                    this.politicalMusic.play().catch(e => console.log('Political music playback failed:', e));
                }
            } else {
                this.backgroundMusic.volume = volume;
                if (this.backgroundMusic.paused) {
                    this.backgroundMusic.play().catch(e => console.log('Lavender music playback failed:', e));
                }
            }
        }
    }

    // Method to stop all audio
    stopAllAudio() {
        this.backgroundMusic.pause();
        this.backgroundMusic.currentTime = 0;
        this.politicalMusic.pause();
        this.politicalMusic.currentTime = 0;
        console.log('ðŸ”‡ All audio stopped');
    }

    getInitialWidget() {
        // Check URL parameters for starting widget
        const urlParams = new URLSearchParams(window.location.search);
        const widgetParam = urlParams.get('widget');
        if (widgetParam) {
            const widgetNum = parseInt(widgetParam);
            if (widgetNum >= 1 && widgetNum <= 12) {
                return widgetNum;
            }
        }
        return 1; // Default to first widget
    }

    setupAudioContext() {
        // Create audio context on user interaction
        const handleFirstInteraction = () => {
            if (this.currentWidget === 1) {
                // 50% volume for FirstWidget only - lavender soundtrack
                this.switchAudioTrack('lavender', 0.5);
            } else if (this.currentWidget <= 5) {
                // 8% volume from SecondWidget onwards (until politics_1 video) - lavender soundtrack
                this.switchAudioTrack('lavender', 0.08);
            } else {
                // From VideoWidget4 (politics_1) onwards - political party music at 8%
                this.switchAudioTrack('political', 0.08);
            }
            // Remove the event listeners once audio is playing
            document.removeEventListener('click', handleFirstInteraction);
            document.removeEventListener('keydown', handleFirstInteraction);
        };

        // Add event listeners for first interaction
        document.addEventListener('click', handleFirstInteraction);
        document.addEventListener('keydown', handleFirstInteraction);
    }

    setupCrossPageAudio() {
        // Save audio state when leaving page (for vote.html/results.html navigation)
        window.addEventListener('beforeunload', () => {
            const audioState = {
                currentTrack: this.currentAudioTrack,
                lavenderIsPlaying: !this.backgroundMusic.paused,
                lavenderCurrentTime: this.backgroundMusic.currentTime,
                politicalIsPlaying: !this.politicalMusic.paused,
                politicalCurrentTime: this.politicalMusic.currentTime
            };
            localStorage.setItem('nostalgiaAudioState', JSON.stringify(audioState));
        });
        
        // Try to restore audio state from previous page (if returning from vote/results)
        const audioState = localStorage.getItem('nostalgiaAudioState');
        if (audioState) {
            const state = JSON.parse(audioState);
            if (state.currentTrack) {
                this.currentAudioTrack = state.currentTrack;
                
                if (state.currentTrack === 'lavender' && state.lavenderIsPlaying && state.lavenderCurrentTime !== undefined) {
                    // Set the time but don't auto-play yet (will start on user interaction)
                    this.backgroundMusic.currentTime = state.lavenderCurrentTime;
                } else if (state.currentTrack === 'political' && state.politicalIsPlaying && state.politicalCurrentTime !== undefined) {
                    // Set the time but don't auto-play yet (will start on user interaction)
                    this.politicalMusic.currentTime = state.politicalCurrentTime;
                }
            }
            // Clear the stored state since we've restored it
            localStorage.removeItem('nostalgiaAudioState');
        }
    }

    init() {
        // Clear container
        this.widgetContainer.innerHTML = '';
        
        // Initialize widgets
        this.widgets = [
            new FirstWidget(this.widgetContainer, 1),
            new SecondWidget(this.widgetContainer, 2),
            new VideoWidget(this.widgetContainer, 3),
            new VideoWidget2(this.widgetContainer, 4),
            new VideoWidget3(this.widgetContainer, 5),
            new VideoWidget4(this.widgetContainer, 6),
            new VideoWidget5(this.widgetContainer, 7),
            new VideoWidget6(this.widgetContainer, 8),
            new VideoWidget7(this.widgetContainer, 9),
            new VideoWidget8(this.widgetContainer, 10),
            new VideoWidget9(this.widgetContainer, 11),
            new VideoWidget10(this.widgetContainer, 12)
        ];

        // Mount all widgets
        this.widgets.forEach(widget => widget.mount());
        
        // Set initial widget positions based on currentWidget
        this.updateWidgetPositions();
        this.updateNavigationButtons();
        
        // Set up navigation
        this.setupNavigation();

        // Music will start playing on first user interaction
    }

    setupNavigation() {
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');

        prevBtn.addEventListener('click', () => {
            this.applyVisualFeedbackAndNavigate(() => {
                this.navigateToWidget(-1);
            });
        });
        nextBtn.addEventListener('click', () => {
            // If on VideoWidget (widget 3), redirect to vote.html immediately
            if (this.currentWidget === 3) {
                this.applyVisualFeedbackAndRedirect('/vote.html');
            } else {
                this.applyVisualFeedbackAndNavigate(() => {
                    this.navigateToWidget(1);
                });
            }
        });

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key === 'f') {
                // For Widget 1 (FirstWidget), let it handle its own navigation
                if (this.currentWidget === 1) {
                    // FirstWidget handles this itself - do nothing here
                    return;
                } else if (this.currentWidget === 2) {
                    // Toggle back to first widget with visual feedback
                    this.applyVisualFeedbackAndNavigate(() => {
                        this.navigateToWidget(-1);
                    });
                }
            } else if (key === 'a') {
                // Special case: if on widget 4 (VideoWidget2), let it handle its own navigation
                if (this.currentWidget === 4) {
                    // VideoWidget2 handles this itself - do nothing here
                    return;
                } else if (this.currentWidget === 5) {
                    // VideoWidget3 handles this itself - do nothing here
                    return;
                } else if (this.currentWidget === 6) {
                    // VideoWidget4 handles this itself - do nothing here
                    return;
                } else if (this.currentWidget === 7) {
                    // VideoWidget5 handles this itself - do nothing here
                    return;
                }
                this.applyVisualFeedbackAndNavigate(() => {
                    this.navigateToWidget(-1);
                });
            } else if (key === 'd') {
                // Special case: if on widget 3 (VideoWidget), redirect to vote.html immediately
                if (this.currentWidget === 3) {
                    this.applyVisualFeedbackAndRedirect('/vote.html');
                } else if (this.currentWidget === 4) {
                    // VideoWidget2 handles this itself - do nothing here
                    return;
                } else if (this.currentWidget === 5) {
                    // VideoWidget3 handles this itself - do nothing here
                    return;
                } else if (this.currentWidget === 6) {
                    // VideoWidget4 handles this itself - do nothing here
                    return;
                } else if (this.currentWidget === 7) {
                    // VideoWidget5 handles this itself - do nothing here
                    return;
                } else {
                    // Navigate to next widget (e.g., SecondWidget -> VideoWidget)
                    this.applyVisualFeedbackAndNavigate(() => {
                        this.navigateToWidget(1);
                    });
                }
            } else if (key === 'r') {
                // Enhanced reset functionality with debugging and fallbacks
                console.log('ðŸ”„ RESET TRIGGERED - Starting comprehensive reset process');
                this.performComprehensiveReset();
            }
        });

        // Listen for custom navigation events from widgets
        document.addEventListener('navigateToWidget', (event) => {
            const targetWidget = event.detail.targetWidget;
            console.log(`Custom navigation event: moving to widget ${targetWidget}`);
            
            // Clean up current widget before navigation
            this.cleanupCurrentWidget();
            
            this.currentWidget = targetWidget;
            this.updateWidgetPositions();
            this.updateNavigationButtons();
            
            // Handle background music based on current widget
            if (this.currentWidget === 1) {
                // 50% volume for FirstWidget only - lavender soundtrack
                this.switchAudioTrack('lavender', 0.5);
            } else if (this.currentWidget <= 5) {
                // 8% volume from SecondWidget onwards (until politics_1 video) - lavender soundtrack
                this.switchAudioTrack('lavender', 0.08);
            } else {
                // From VideoWidget4 (politics_1) onwards - political party music at 8%
                this.switchAudioTrack('political', 0.08);
            }
        });

        // Listen for comprehensive reset events from widgets
        document.addEventListener('comprehensiveReset', (event) => {
            console.log(`ðŸ”„ Comprehensive reset triggered by: ${event.detail.source}`);
            this.performComprehensiveReset();
        });

        this.updateNavigationButtons();
    }

    applyVisualFeedbackAndNavigate(navigationFunction) {
        // Prevent interactions during transition
        document.body.style.pointerEvents = 'none';
        
        // Clean up any potential audio bleeding first
        this.cleanupCurrentWidget();
        
        // Apply visual feedback (could be icon changes, etc.)
        this.showNavigationFeedback();
        
        // Execute navigation after 1 second
        setTimeout(() => {
            navigationFunction();
            // Re-enable interactions
            document.body.style.pointerEvents = 'auto';
        }, 1000);
    }

    applyVisualFeedbackAndRedirect(url) {
        // Prevent interactions during transition
        document.body.style.pointerEvents = 'none';
        
        // Save audio state before redirect
        const audioState = {
            currentTrack: this.currentAudioTrack,
            lavenderIsPlaying: !this.backgroundMusic.paused,
            lavenderCurrentTime: this.backgroundMusic.currentTime,
            politicalIsPlaying: !this.politicalMusic.paused,
            politicalCurrentTime: this.politicalMusic.currentTime
        };
        localStorage.setItem('nostalgiaAudioState', JSON.stringify(audioState));
        
        // Clean up current widget
        this.cleanupCurrentWidget();
        
        // Apply visual feedback
        this.showNavigationFeedback();
        
        // Redirect after 1 second
        setTimeout(() => {
            window.location.href = url;
        }, 1000);
    }

    showNavigationFeedback() {
        // Visual feedback could include icon changes, flash effects, etc.
        // Set navigation icons to filled state during transition
        const nextIcon = document.getElementById('nextIcon');
        const backIcon = document.getElementById('backIcon');
        
        // Change icons to filled state and keep them filled during navigation
        if (nextIcon && nextIcon.src.includes('next.svg')) {
            nextIcon.src = '/static/icons/nextfilled.svg';
        }
        
        if (backIcon && backIcon.src.includes('back.svg')) {
            backIcon.src = '/static/icons/backfilled.svg';
        }
        
        // Icons will be reset when updateWidgetPositions() is called after navigation
    }

    navigateToWidget(direction) {
        const newWidget = this.currentWidget + direction;
        if (newWidget < 1 || newWidget > this.widgets.length) return;
        
        // Clean up current widget before navigation
        this.cleanupCurrentWidget();
        
        this.currentWidget = newWidget;
        this.updateWidgetPositions();
        this.updateNavigationButtons();
        
        // Handle background music based on current widget
        if (this.currentWidget === 1) {
            // 50% volume for FirstWidget only - lavender soundtrack
            this.switchAudioTrack('lavender', 0.5);
        } else if (this.currentWidget <= 5) {
            // 8% volume from SecondWidget onwards (until politics_1 video) - lavender soundtrack
            this.switchAudioTrack('lavender', 0.08);
        } else {
            // From VideoWidget4 (politics_1) onwards - political party music at 8%
            this.switchAudioTrack('political', 0.08);
        }
        
        // Extra safety: ensure video cleanup when not on VideoWidget3
        if (this.currentWidget !== 5) {
            this.preventVideoAudioBleeding();
        }
    }

    preventVideoAudioBleeding() {
        // Find VideoWidget3's video element and ensure it's not playing any videos
        const videoWidget3Element = document.querySelector('[data-widget="5"] video');
        if (videoWidget3Element) {
            const source = videoWidget3Element.querySelector('source');
            if (source && source.src.includes('secondpart.mp4')) {
                console.log('Preventing video audio bleeding - resetting VideoWidget3');
                videoWidget3Element.pause();
                videoWidget3Element.currentTime = 0;
                // VideoWidget3 now shows an image by default, so we reset to secondpart.mp4 but keep it hidden
                source.src = '/static/videos/secondpart.mp4';
                videoWidget3Element.load();
            }
        }
    }

    cleanupCurrentWidget() {
        console.log('Cleaning up current widget to prevent audio bleeding');
        
        // Stop any playing videos and clear their sources to prevent audio bleeding
        const allVideos = document.querySelectorAll('video');
        allVideos.forEach((video, index) => {
            if (!video.paused) {
                console.log(`Stopping video ${index + 1}: ${video.src}`);
                video.pause();
                video.currentTime = 0;
            }
            // Clear source and reload to stop any background loading
            const currentSrc = video.src;
            if (currentSrc) {
                video.src = '';
                video.load();
            }
        });
        
        // Specifically target any videos that might be preloading
        const videoWidget3 = document.getElementById('mainVideo3');
        if (videoWidget3) {
            const source = videoWidget3.querySelector('source');
            if (source && source.src.includes('secondpart.mp4')) {
                console.log('âš ï¸ FOUND PLAYING VIDEO - Cleaning up to prevent audio bleeding');
                videoWidget3.pause();
                videoWidget3.currentTime = 0;
                // VideoWidget3 now shows an image by default, so we reset to secondpart.mp4 but keep it hidden
                source.src = '/static/videos/secondpart.mp4';
                videoWidget3.load();
            }
        }
        
        // Call deactivate on current widget if it has the method
        const currentWidgetObj = this.widgets[this.currentWidget - 1];
        if (currentWidgetObj && typeof currentWidgetObj.deactivate === 'function') {
            currentWidgetObj.deactivate();
        }
    }

    updateWidgetPositions() {
        this.widgets.forEach(widget => {
            const widgetNum = parseInt(widget.element.dataset.widget);
            if (widgetNum === this.currentWidget) {
                widget.element.classList.add('widget-active');
                widget.element.classList.remove('widget-inactive');
                
                // Call activate method if widget has one (for reset functionality)
                if (typeof widget.activate === 'function') {
                    widget.activate();
                }
            } else {
                widget.element.classList.remove('widget-active');
                widget.element.classList.add('widget-inactive');
            }
        });
        
        // Reset navigation button icons when changing widgets (after navigation is complete)
        setTimeout(() => {
            this.resetNavigationIcons();
        }, 50); // Small delay to ensure navigation is complete
    }
    
    resetNavigationIcons() {
        // Reset navigation button icons to default state
        const backIcon = document.getElementById('backIcon');
        const nextIcon = document.getElementById('nextIcon');
        if (backIcon) backIcon.src = '/static/icons/back.svg';
        if (nextIcon) nextIcon.src = '/static/icons/next.svg';
    }

    updateNavigationButtons() {
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        prevBtn.disabled = this.currentWidget === 1;
        nextBtn.disabled = this.currentWidget === this.widgets.length;
    }

    performComprehensiveReset() {
        // Generate unique reset ID for tracking
        const resetId = `RESET_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const resetStartTime = performance.now();
        
        this.resetAttempts++;
        this.lastResetTime = Date.now();
        this.updateDebugPanel('Starting Reset...');
        
        // Enhanced system state logging
        this.logSystemStateBeforeReset(resetId);
        
        console.log(`ðŸ”„ COMPREHENSIVE RESET #${this.resetAttempts} [${resetId}] - Starting enhanced reset process`);
        console.log(`ðŸ“Š Reset Context: From Widget ${this.currentWidget}, Audio: ${this.currentAudioTrack}, Videos: ${document.querySelectorAll('video:not([src=""])').length} loaded`);
        
        try {
            // Phase 0: Enhanced preparation with performance tracking
            console.log(`ðŸ”„ [${resetId}] Phase 0: Enhanced Preparation`);
            const prepStartTime = performance.now();
            
            // Prevent interactions during reset
            document.body.style.pointerEvents = 'none';
            
            // Log current widget state
            this.logCurrentWidgetState(resetId);
            
            // Preserve voting data before reset
            this.preserveVotingData();
            
            console.log(`âœ… [${resetId}] Phase 0 completed in ${(performance.now() - prepStartTime).toFixed(2)}ms`);
            
            // Phase 1: Clean up current state with enhanced tracking
            console.log(`ðŸ§¹ [${resetId}] Phase 1: Enhanced State Cleanup`);
            const cleanupStartTime = performance.now();
            this.resetCurrentState(resetId);
            console.log(`âœ… [${resetId}] Phase 1 completed in ${(performance.now() - cleanupStartTime).toFixed(2)}ms`);
            
            // Phase 2: Reset all widgets with detailed tracking
            console.log(`ðŸ”§ [${resetId}] Phase 2: Enhanced Widget Reset`);
            const widgetResetStartTime = performance.now();
            this.resetAllWidgets(resetId);
            console.log(`âœ… [${resetId}] Phase 2 completed in ${(performance.now() - widgetResetStartTime).toFixed(2)}ms`);
            
            // Phase 3: Reset audio system with performance tracking
            console.log(`ðŸŽµ [${resetId}] Phase 3: Enhanced Audio Reset`);
            const audioResetStartTime = performance.now();
            this.resetAudioSystem(resetId);
            console.log(`âœ… [${resetId}] Phase 3 completed in ${(performance.now() - audioResetStartTime).toFixed(2)}ms`);
            
            // Phase 4: Reset navigation with performance tracking
            console.log(`ðŸ§­ [${resetId}] Phase 4: Enhanced Navigation Reset`);
            const navResetStartTime = performance.now();
            this.resetNavigationSystem(resetId);
            console.log(`âœ… [${resetId}] Phase 4 completed in ${(performance.now() - navResetStartTime).toFixed(2)}ms`);
            
            // Phase 5: Navigate to initial state with performance tracking
            console.log(`ðŸ  [${resetId}] Phase 5: Enhanced Navigation to Initial State`);
            const navStartTime = performance.now();
            this.navigateToInitialState(resetId);
            console.log(`âœ… [${resetId}] Phase 5 completed in ${(performance.now() - navStartTime).toFixed(2)}ms`);
            
            // Final success logging
            const totalResetTime = performance.now() - resetStartTime;
            this.updateDebugPanel('Reset Complete');
            this.logResetSuccess(resetId, totalResetTime);
            
            console.log(`ðŸŽ‰ COMPREHENSIVE RESET #${this.resetAttempts} [${resetId}] - All phases completed successfully in ${totalResetTime.toFixed(2)}ms`);
            
        } catch (error) {
            const totalResetTime = performance.now() - resetStartTime;
            console.error(`âŒ RESET ERROR #${this.resetAttempts} [${resetId}] - Error after ${totalResetTime.toFixed(2)}ms:`, error);
            this.logResetError(resetId, error, totalResetTime);
            this.updateDebugPanel('Reset Failed - Using Fallback');
            this.fallbackReset(resetId);
        }
    }

    preserveVotingData() {
        console.log('ðŸ’¾ RESET - Preserving voting data');
        
        try {
            // Preserve existing voting data
            const existingVote1 = localStorage.getItem('userVote');
            const existingVote2 = localStorage.getItem('userVote2');
            const audioState = localStorage.getItem('nostalgiaAudioState');
            
            // Create backup of important data
            const backupData = {
                vote1: existingVote1,
                vote2: existingVote2,
                audioState: audioState,
                timestamp: Date.now(),
                resetReason: 'comprehensive_reset'
            };
            
            localStorage.setItem('nostalgiaDataBackup', JSON.stringify(backupData));
            console.log('ðŸ’¾ RESET - Voting data preserved successfully');
            
        } catch (error) {
            console.error('âŒ RESET - Failed to preserve voting data:', error);
        }
    }

    resetCurrentState(resetId) {
        console.log(`ðŸ§¹ [${resetId}] RESET - Phase 1: Enhanced Current State Cleanup`);
        
        try {
            // Enhanced video cleanup with detailed logging
            const allVideos = document.querySelectorAll('video');
            console.log(`ðŸŽ¬ [${resetId}] Found ${allVideos.length} video elements to process`);
            
            allVideos.forEach((video, index) => {
                try {
                    const videoInfo = {
                        index: index + 1,
                        src: video.src || 'No source',
                        paused: video.paused,
                        currentTime: video.currentTime.toFixed(2),
                        duration: video.duration ? video.duration.toFixed(2) : 'Unknown'
                    };
                    
                    if (!video.paused) {
                        console.log(`ðŸ›‘ [${resetId}] Stopping playing video ${index + 1}:`, videoInfo);
                        video.pause();
                        video.currentTime = 0;
                    } else {
                        console.log(`âœ… [${resetId}] Video ${index + 1} already paused:`, videoInfo);
                    }
                    
                    video.src = '';
                    video.load();
                    
                } catch (videoError) {
                    console.warn(`âš ï¸ [${resetId}] Could not reset video ${index + 1}:`, videoError);
                }
            });
            
            // Enhanced timer cleanup with detailed logging
            this.clearAllTimers(resetId);
            
            console.log(`âœ… [${resetId}] Current state cleanup completed - ${allVideos.length} videos processed`);
            
        } catch (error) {
            console.error(`âŒ [${resetId}] Failed to clean current state:`, error);
            throw error; // Re-throw to trigger fallback
        }
    }

    resetAllWidgets(resetId) {
        console.log(`ðŸ”§ [${resetId}] RESET - Phase 2: Enhanced Widget Reset (${this.widgets.length} widgets)`);
        
        const widgetResetResults = [];
        
        try {
            this.widgets.forEach((widget, index) => {
                const widgetStartTime = performance.now();
                const widgetNum = index + 1;
                const widgetResult = {
                    widgetNum,
                    widgetType: widget.constructor.name,
                    success: false,
                    time: 0,
                    error: null
                };
                
                try {
                    console.log(`ðŸ”§ [${resetId}] Resetting Widget ${widgetNum} (${widget.constructor.name})`);
                    
                    // Call deactivate method if available
                    if (typeof widget.deactivate === 'function') {
                        widget.deactivate();
                        console.log(`âœ… [${resetId}] Widget ${widgetNum} deactivated`);
                    } else {
                        console.log(`â„¹ï¸ [${resetId}] Widget ${widgetNum} has no deactivate method`);
                    }
                    
                    // Reset widget classes
                    if (widget.element) {
                        const wasActive = widget.element.classList.contains('widget-active');
                        widget.element.classList.remove('widget-active');
                        widget.element.classList.add('widget-inactive');
                        console.log(`ðŸŽ¯ [${resetId}] Widget ${widgetNum} CSS classes updated (was active: ${wasActive})`);
                    }
                    
                    // Special reset logic for specific widgets
                    this.resetSpecificWidget(widget, widgetNum, resetId);
                    
                    widgetResult.success = true;
                    widgetResult.time = performance.now() - widgetStartTime;
                    console.log(`âœ… [${resetId}] Widget ${widgetNum} reset completed in ${widgetResult.time.toFixed(2)}ms`);
                    
                } catch (widgetError) {
                    widgetResult.error = widgetError.message;
                    widgetResult.time = performance.now() - widgetStartTime;
                    console.warn(`âš ï¸ [${resetId}] Could not reset widget ${widgetNum}:`, widgetError);
                }
                
                widgetResetResults.push(widgetResult);
            });
            
            // Summary logging
            const successfulResets = widgetResetResults.filter(r => r.success).length;
            const totalTime = widgetResetResults.reduce((sum, r) => sum + r.time, 0);
            
            console.log(`âœ… [${resetId}] Widget reset summary: ${successfulResets}/${this.widgets.length} successful in ${totalTime.toFixed(2)}ms`);
            
            // Log any failures
            const failures = widgetResetResults.filter(r => !r.success);
            if (failures.length > 0) {
                console.warn(`âš ï¸ [${resetId}] Widget reset failures:`, failures);
            }
            
        } catch (error) {
            console.error(`âŒ [${resetId}] Failed to reset widgets:`, error);
            throw error; // Re-throw to trigger fallback
        }
    }
    }

    resetSpecificWidget(widget, widgetNum, resetId) {
        try {
            // Reset specific widget states
            switch (widgetNum) {
                case 2: // SecondWidget
                    console.log(`ðŸ“Š [${resetId}] Resetting SecondWidget countdown and UI`);
                    if (widget.countdownTimer) {
                        clearTimeout(widget.countdownTimer);
                        widget.countdownTimer = null;
                    }
                    if (widget.countdownContainer) {
                        widget.countdownContainer.style.opacity = '0';
                    }
                    if (widget.countdownBar) {
                        widget.countdownBar.style.transition = 'none';
                        widget.countdownBar.style.width = '100%';
                    }
                    break;
                    
                case 3: // VideoWidget
                case 4: // VideoWidget2
                case 5: // VideoWidget3
                case 6: // VideoWidget4
                case 10: // VideoWidget8
                case 12: // VideoWidget10
                    // Reset video widgets to their initial video sources
                    const videoElement = widget.element?.querySelector('video');
                    if (videoElement) {
                        console.log(`ðŸŽ¬ [${resetId}] Resetting video widget ${widgetNum} with source reset`);
                        videoElement.pause();
                        videoElement.currentTime = 0;
                        videoElement.src = ''; // Clear src to stop any loading
                        
                        // Reset to initial video source but DON'T load yet
                        const source = videoElement.querySelector('source');
                        if (source) {
                            switch (widgetNum) {
                                case 3: // VideoWidget - firstpart.mp4
                                    source.src = '/static/videos/firstpart.mp4';
                                    console.log(`ðŸŽ¬ [${resetId}] VideoWidget reset to firstpart.mp4`);
                                    break;
                                case 4: // VideoWidget2 - transititonvote2.mp4
                                    source.src = '/static/videos/transititonvote2.mp4';
                                    console.log(`ðŸŽ¬ [${resetId}] VideoWidget2 reset to transititonvote2.mp4`);
                                    break;
                                case 5: // VideoWidget3 - now shows image, reset video source but keep hidden
                                    source.src = '/static/videos/secondpart.mp4';
                                    console.log(`ðŸŽ¬ [${resetId}] VideoWidget3 reset to secondpart.mp4 (image mode)`);
                                    break;
                                case 6: // VideoWidget4
                                    source.src = '/static/videos/politics_1.mp4';
                                    console.log(`ðŸŽ¬ [${resetId}] VideoWidget4 reset to politics_1.mp4`);
                                    break;
                                case 10: // VideoWidget8
                                    source.src = '/static/videos/politics_3.mp4';
                                    console.log(`ðŸŽ¬ [${resetId}] VideoWidget8 reset to politics_3.mp4`);
                                    break;
                                case 12: // VideoWidget10
                                    source.src = '/static/videos/rising.mp4';
                                    console.log(`ðŸŽ¬ [${resetId}] VideoWidget10 reset to rising.mp4`);
                                    break;
                            }
                            // DON'T call videoElement.load() here - let each widget load when activated
                        }
                    }
                    break;
                    
                case 7: // VideoWidget5
                case 8: // VideoWidget6
                case 9: // VideoWidget7
                    // Reset law widgets - ensure all buttons are in default state
                    console.log(`âš–ï¸ [${resetId}] Resetting law widget ${widgetNum} button states`);
                    const buttons = widget.element?.querySelectorAll('.law-button');
                    buttons?.forEach((button, buttonIndex) => {
                        const img = button.querySelector('img');
                        if (img) {
                            const oldSrc = img.src;
                            img.src = img.src.replace('filled', '').replace('chosen', '');
                            if (oldSrc !== img.src) {
                                console.log(`ðŸ”„ [${resetId}] Button ${buttonIndex + 1} icon reset: ${oldSrc} -> ${img.src}`);
                            }
                        }
                    });
                    break;
            }
        } catch (error) {
            console.warn(`âš ï¸ [${resetId}] Could not apply specific reset for widget ${widgetNum}:`, error);
        }
    }

    resetAudioSystem() {
        console.log('ðŸŽµ RESET - Phase 3: Resetting audio system');
        
        try {
            // Stop all audio and reset to lavender soundtrack
            this.stopAllAudio();
            this.currentAudioTrack = 'lavender';
            this.backgroundMusic.volume = 0.5; // Reset to 50% volume for widget 1
            
            // Clear any audio-related localStorage except voting data
            const audioState = localStorage.getItem('nostalgiaAudioState');
            if (audioState) {
                localStorage.removeItem('nostalgiaAudioState');
            }
            
            console.log('âœ… RESET - Audio system reset to lavender soundtrack');
            
        } catch (error) {
            console.error('âŒ RESET - Failed to reset audio system:', error);
        }
    }

    resetNavigationSystem() {
        console.log('ðŸ§­ RESET - Phase 4: Resetting navigation system');
        
        try {
            // Reset navigation icons
            this.resetNavigationIcons();
            
            // Reset navigation buttons
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            if (prevBtn) prevBtn.disabled = true; // Will be at widget 1
            if (nextBtn) nextBtn.disabled = false;
            
            console.log('âœ… RESET - Navigation system reset');
            
        } catch (error) {
            console.error('âŒ RESET - Failed to reset navigation system:', error);
        }
    }

    navigateToInitialState() {
        console.log('ðŸ  RESET - Phase 5: Navigating to initial state');
        
        try {
            // Set current widget to 1
            this.currentWidget = 1;
            
            // Update widget positions
            this.updateWidgetPositions();
            this.updateNavigationButtons();
            
            // Re-enable interactions after a delay
            setTimeout(() => {
                document.body.style.pointerEvents = 'auto';
                console.log('âœ… RESET - Navigation to initial state completed');
            }, 500);
            
        } catch (error) {
            console.error('âŒ RESET - Failed to navigate to initial state:', error);
            this.fallbackReset();
        }
    }

    clearAllTimers() {
        console.log('â° RESET - Clearing all timers');
        
        try {
            // Clear any widget-specific timers
            this.widgets.forEach((widget, index) => {
                try {
                    if (widget.countdownTimer) {
                        clearTimeout(widget.countdownTimer);
                        widget.countdownTimer = null;
                    }
                    if (widget.observer) {
                        widget.observer.disconnect();
                    }
                } catch (timerError) {
                    console.warn(`âš ï¸ RESET - Could not clear timer for widget ${index + 1}:`, timerError);
                }
            });
            
        } catch (error) {
            console.error('âŒ RESET - Failed to clear timers:', error);
        }
    }

    fallbackReset() {
        console.log('ðŸš¨ FALLBACK RESET - Attempting simple page reload');
        
        try {
            // Preserve voting data one more time
            this.preserveVotingData();
            
            // Simple fallback - reload page to widget 1
            setTimeout(() => {
                window.location.href = '/?widget=1';
            }, 1000);
            
        } catch (error) {
            console.error('ðŸ’¥ CRITICAL RESET FAILURE - Manual intervention required:', error);
            alert('Reset failed. Please refresh the page manually.');
        }
    }

    // Debug and monitoring functionality
    initializeResetMonitoring() {
        // Add debug panel if in development mode
        if (window.location.hostname === 'localhost' || window.location.search.includes('debug=true')) {
            this.createDebugPanel();
        }
        
        // Monitor reset attempts
        this.resetAttempts = 0;
        this.lastResetTime = null;
        this.resetHistory = []; // Track reset history for analysis
        this.successfulResets = 0;
        this.failedResets = 0;
        
        // Add global error handler for reset failures
        window.addEventListener('error', (event) => {
            if (event.message.includes('RESET') || event.message.includes('reset')) {
                console.error('ðŸš¨ RESET ERROR DETECTED:', event.error);
                this.handleResetError(event.error);
            }
        });
        
        // Log initialization
        console.log('ðŸ”§ Reset monitoring system initialized');
    }

    logSystemStateBeforeReset(resetId) {
        const systemState = {
            resetId,
            timestamp: new Date().toISOString(),
            currentWidget: this.currentWidget,
            currentAudioTrack: this.currentAudioTrack,
            videosLoaded: document.querySelectorAll('video:not([src=""])').length,
            videosPlaying: document.querySelectorAll('video:not([paused])').length,
            activeWidgets: document.querySelectorAll('.widget-active').length,
            userInteractionEnabled: document.body.style.pointerEvents !== 'none',
            localStorage: {
                voteData: !!localStorage.getItem('voteData'),
                vote2Data: !!localStorage.getItem('vote2Data'),
                audioState: !!localStorage.getItem('nostalgiaAudioState')
            }
        };
        
        console.log(`ðŸ“Š [${resetId}] System State Before Reset:`, systemState);
        
        // Store in reset history
        this.resetHistory.push({
            ...systemState,
            phase: 'BEFORE_RESET'
        });
    }

    logCurrentWidgetState(resetId) {
        const currentWidgetObj = this.widgets[this.currentWidget - 1];
        const widgetState = {
            resetId,
            widgetNumber: this.currentWidget,
            widgetType: currentWidgetObj ? currentWidgetObj.constructor.name : 'Unknown',
            hasDeactivateMethod: !!(currentWidgetObj && typeof currentWidgetObj.deactivate === 'function'),
            hasActivateMethod: !!(currentWidgetObj && typeof currentWidgetObj.activate === 'function'),
            element: {
                exists: !!currentWidgetObj?.element,
                isActive: currentWidgetObj?.element?.classList.contains('widget-active'),
                hasVideos: (currentWidgetObj?.element?.querySelectorAll('video') || []).length > 0,
                hasTimers: !!(currentWidgetObj?.countdownTimer || currentWidgetObj?.observer)
            }
        };
        
        console.log(`ðŸŽ¯ [${resetId}] Current Widget State:`, widgetState);
    }

    logResetSuccess(resetId, totalTime) {
        this.successfulResets++;
        
        const successData = {
            resetId,
            timestamp: new Date().toISOString(),
            totalTime: totalTime.toFixed(2) + 'ms',
            resetAttempts: this.resetAttempts,
            successRate: ((this.successfulResets / this.resetAttempts) * 100).toFixed(1) + '%',
            finalState: {
                currentWidget: this.currentWidget,
                audioTrack: this.currentAudioTrack,
                interactionsEnabled: document.body.style.pointerEvents !== 'none'
            }
        };
        
        console.log(`ðŸŽ‰ [${resetId}] Reset Success Data:`, successData);
        
        // Store in reset history
        this.resetHistory.push({
            ...successData,
            phase: 'SUCCESS'
        });
        
        // Limit history to last 50 resets
        if (this.resetHistory.length > 100) {
            this.resetHistory = this.resetHistory.slice(-50);
        }
    }

    logResetError(resetId, error, totalTime) {
        this.failedResets++;
        
        const errorData = {
            resetId,
            timestamp: new Date().toISOString(),
            error: {
                message: error.message,
                stack: error.stack,
                name: error.name
            },
            totalTime: totalTime.toFixed(2) + 'ms',
            resetAttempts: this.resetAttempts,
            failureRate: ((this.failedResets / this.resetAttempts) * 100).toFixed(1) + '%',
            systemState: {
                currentWidget: this.currentWidget,
                videosStillPlaying: document.querySelectorAll('video:not([paused])').length,
                interactionsEnabled: document.body.style.pointerEvents !== 'none'
            }
        };
        
        console.error(`ðŸ’¥ [${resetId}] Reset Error Data:`, errorData);
        
        // Store in reset history
        this.resetHistory.push({
            ...errorData,
            phase: 'ERROR'
        });
    }

    createDebugPanel() {
        const debugPanel = document.createElement('div');
        debugPanel.id = 'resetDebugPanel';
        debugPanel.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            z-index: 10000;
            max-width: 300px;
            display: none;
        `;
        
        debugPanel.innerHTML = `
            <div><strong>ðŸ”„ Reset Debug Panel</strong></div>
            <div>Current Widget: <span id="debugCurrentWidget">${this.currentWidget}</span></div>
            <div>Reset Attempts: <span id="debugResetAttempts">0</span></div>
            <div>Last Reset: <span id="debugLastReset">Never</span></div>
            <div>Status: <span id="debugStatus">Ready</span></div>
            <button onclick="this.parentElement.style.display='none'" style="margin-top:5px;padding:2px 5px;">Hide</button>
        `;
        
        document.body.appendChild(debugPanel);
        
        // Show debug panel with Ctrl+Shift+D
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
            }
        });
    }

    updateDebugPanel(status = 'Ready') {
        const panel = document.getElementById('resetDebugPanel');
        if (panel) {
            const currentWidgetSpan = document.getElementById('debugCurrentWidget');
            const resetAttemptsSpan = document.getElementById('debugResetAttempts');
            const lastResetSpan = document.getElementById('debugLastReset');
            const statusSpan = document.getElementById('debugStatus');
            
            if (currentWidgetSpan) currentWidgetSpan.textContent = this.currentWidget;
            if (resetAttemptsSpan) resetAttemptsSpan.textContent = this.resetAttempts;
            if (lastResetSpan) lastResetSpan.textContent = this.lastResetTime ? new Date(this.lastResetTime).toLocaleTimeString() : 'Never';
            if (statusSpan) statusSpan.textContent = status;
        }
    }

    handleResetError(error) {
        console.error('ðŸš¨ RESET ERROR HANDLER:', error);
        this.updateDebugPanel('Error: ' + error.message);
        
        // Attempt recovery
        setTimeout(() => {
            console.log('ðŸ”§ ATTEMPTING RESET RECOVERY');
            this.fallbackReset();
        }, 2000);
    }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    new WidgetManager();
});